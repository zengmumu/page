符号优先

算符优先是编程中的一个非常重要的概念。它是运算顺序的数学思想（先乘除后加减）的扩展，包括其他运算符，例如布尔逻辑中的运算符。

下面的代码显示，＝＝具有比or更高的优先级：
<pre class="brush:python;toolbar:false;">
>>> False == False or True
True
>>> False == (False or True)
False
>>> (False == False) or True
True
<pre/>
<div class="tip">
Python的运算顺序与普通数学相同：先括号，然后求幂，然后乘法/除法，然后加/减。
</div>
    
这段代码的运行结果是？ B
<pre class="brush:python;toolbar:false;">
if 1 + 1 * 3 == 6:
   print("Yes")
else:
   print("No")
</pre>
Yes
No


符号优先

下表列出了所有Python的运算符，从最高优先级到最低级别。
<img src="https://files.jb51.net/file_images/article/201510/20151013164559656.jpg?2015913164610">
<img src="https://img-blog.csdn.net/20161018221955409?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">


这段代码的结果是  A
<pre class="brush:python;toolbar:false;">
x = 4
y = 2
if not 1 + 1 == y or x == 4 and 7 == 8:
  print("Yes")
elif x > y:
  print("No")
</pre>
Yes No
No
Yes



while 循环

<div>

</div>
<p>if语句运行一次，如果它的条件计算为true，并且如果它计算为false，则永远不会运行。</p>
<p>
while语句类似，但它可以运行不止一次。只要条件成立，就重复执行内部的语句。一旦计算为false，则执行下一部分代码。
</p>
<p> 下面是一个while循环，包含一个从1到5的变量，循环结束。</p>

<pre class="brush:python;toolbar:false;">
i = 1
while i <=5:
   print(i)
   i = i + 1

print("Finished!")
Try It Yourself
</pre>
结果:
<pre class="brush:python;toolbar:false;">
>>>
1
2
3
4
5
Finished!
>>>
</pre>

<div class="tip">
他在while循环中的代码重复执行。这叫做迭代。
</div>


多少个数字将会被打印  4
<pre class="brush:python;toolbar:false;">
i = 3
while i>=0:
   print(i)
   i = i - 1
</pre>
  
 [space]



 while 循环-无限循环
<p>无限循环是一种特殊的while循环，它从不停止运行。它的条件总是为真（True）的。</p>
<p>无限循环案例</p>
<pre class="brush:python;toolbar:false;">
while 1==1:
  print("In the loop") 
Try It Yourself
</pre>
这段程序讲不停的打印 "In the loop". 

<div class="tip">
可以通过使用CTRL C快捷方式或关闭程序来停止程序的执行。
</div>

填空 创建一个循环让x以2递增，并且答应偶数  while : print

x = 0  
[space] x <=20[space]
 
	[space](x)
    x += 2



break语句

<p>若要过早结束while循环，可以使用break语句。
</p>

<p>在循环里，break语句会立即导致循环结束。</p>
<pre class="brush:python;toolbar:false;">
i = 0
while 1==1:
  print(i)
  i = i + 1
  if i >= 5:
    print("Breaking")
    break

print("Finished")


结果:
>>>
0
1
2
3
4
Breaking
Finished
>>>
</pre>
<div class="tip">
在循环外的break语句会导致错误。
</div>





多少数字讲会被打印?  3
<pre class="brush:python;toolbar:false;">
i = 5
while True:
  print(i)
  i = i - 1
  if i <= 2:
    break
</pre>
  [space]




  continue

<p>可以在循环中使用的另一个语句是continue</p>
不像 break, continue 跳回循环的顶部，而不是停止它。 (不执行当次循环continue后面的与语句)
<pre class="brush:python;toolbar:false;">
i = 0
while True:
   i = i +1
   if i == 2:
      print("Skipping 2")
      continue
   if i == 5:
      print("Breaking")
      break
   print(i)

print("Finished")
结果
>>>
1
Skipping 2
3
4
Breaking
Finished
>>>
</pre>
<div class="[space]"></div>
<p>基本上，继续语句停止当前迭代并继续下一个迭代。</p>
<div class="tip">
在循环外的continue语句会导致错误。

</div>



哪个语句结束当前迭代并继续下一个? continue

  

 [space]




Lists
<p>列表是Python中的另一种对象。它们用于存储索引的项目列表。</p>
<p>使用带有逗号分隔项的方括号创建列表。</p>
<p>列表中的某个项目可以使用方括号中的索引访问。</p>

<p>举个例子:</p>
<pre class="brush:python;toolbar:false;">
words = ["Hello", "world", "!"]
print(words[0])
print(words[1])
print(words[2])


结果是:
>>>
Hello
world
!
>>>
</pre>
<div class="tip">第一个列表项的索引是0，而不是</div>
 4


这段代码的结果是? 4
<pre class="brush:python;toolbar:false;">
nums = [5, 4, 3, 2, 1]
print(nums[1])
</pre>
[space]



Lists




用一对空的方括号创建空列表。
<pre class="brush:python;toolbar:false;">
empty_list = []
print(empty_list)


结果:
>>>
[]
>>>
</pre>
<div class="tip">
大多数时候，逗号不会跟随列表中的最后一个项目。然而，把它放在那里是完全有效的，在某些情况下是值得鼓励的。
</div>




这个列表里有多少个项目？  B
[2,]

2
1
3



Lists
<p>通常，列表将包含单个项类型的项目，但也可以包括若干不同类型。</p>

<p>列表也可以嵌套在其他列表中。</p>

<pre class="brush:python;toolbar:false;">

number = 3
things = ["string", 0, [1, 2, number], 4.56]
print(things[1])
print(things[2])
print(things[2][2])
Try It Yourself

结果:
>>>
0
[1, 2, 3]
3
>>>
</pre>
<div class="tip">
列表通常用于表示2D网格，因为Python缺少用于其他语言的多维数组。
</div>



填空,创建列表并打印它的第三个元素。 [,2

list = [space] 42, 55, 67]
print(list[[space]])





Lists
<p>
索引可能超出列表值的范围会导致索引错误。
</p>
<p>
某些类型，如字符串，可以像列表一样索引。索引字符串的行为就像在索引包含字符串中的每个字符的列表一样。
</p><p>
对于其他类型，如整数，索引它们是不可能的，并且会导致类型错误。</p>
<pre class="brush:python;toolbar:false;">
str = "Hello world!"
print(str[6])


结果:
>>>
w
>>>
</pre>

哪一行代码会产生错误 A
<pre class="brush:python;toolbar:false;">

num = [5, 4, 3, [2], 1]
print(num[0])
print(num[3][0])
print(num[5])
</pre>
 4 行
 2 行
 3 行



列表操作
<p>列表索引的某个项目可以重新赋值</p>

举例:
<pre class="brush:python;toolbar:false;">
nums = [7, 7, 7, 7, 7]
nums[2] = 5
print(nums)
Try It Yourself

Result:
>>>
[7, 7, 5, 7, 7]
>>>
</pre>
这段代码的运行结果是？
<pre class="brush:python;toolbar:false;">
nums = [1, 2, 3, 4, 5]
nums[3] = nums[1]
print(nums[3])
</pre>
 [space]

列表操作

<p>
列表list 可以添加也可以相乘，字符串也一样
</p>

举个栗子:
<pre class="brush:python;toolbar:false;">
nums = [1, 2, 3]
print(nums + [4, 5, 6])
print(nums * 3)


结果：
>>>
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 1, 2, 3, 1, 2, 3]
>>>
</pre>
<div class="tip">
列表和字符串在很多方面都是相似的——字符串可以被看作是无法更改的字符列表。
</div>






填空创建一个列表list, 重新赋值第二个元素并且打印整个列表. [,1,nums

nums = [33, 42, 56 [space]
nums[[space]] = 22
print([space])



List 操作
<p>用in语句来检查列表中是否有某个项目，如果返回 True 则有，返回False则没有</p>
<pre class="brush:python;toolbar:false;">
words = ["spam", "egg", "spam", "sausage"]
print("spam" in words)
print("egg" in words)
print("tomato" in words)

结果:
>>>
True
True
False
>>>
</pre>
<div class="tip">
in运算符还用于确定字符串是否是另一个字符串的子字符串。
</div>



这段代码的运行结果是多少? 7
<pre class="brush:python;toolbar:false;">
nums = [10, 9, 8, 7, 6, 5]
nums[0] = nums[1] - 5
if 4 in nums:
  print(nums[3])
else:
  print(nums[4])
</pre>

  [space]



  List 操作

not语句可以检查某个元素不在列表里。如下：
<pre class="brush:python;toolbar:false;">
nums = [1, 2, 3]
print(not 4 in nums)
print(4 not in nums)
print(not 3 in nums)
print(3 not in nums)

结果:
>>>
True
True
False
False
>>>
</pre>



填空，如果列表中包含'z'，打印'Yes' : if,in

letters = ['a', 'b', 'z']
  
 
 [space]"z" [space]:
  print("Yes")




List 函数


更改列表的另一种方法是使用append方法。在列表的最后面添加一项。
<pre class="brush:python;toolbar:false;">
nums = [1, 2, 3]
nums.append(4)
print(nums)
Try It Yourself

Result:
>>>
[1, 2, 3, 4]
>>>
</pre>
<div class="tip">
也有添加在前的方法，后面会介绍
</div>



这段代码的运行结果是? B
<pre class="brush:python;toolbar:false;">
words = ["hello"]
words.append("world")
print(words[1])
</pre>
An error occurs
world
hello



List 函数

len方法用来查看列表中项目的个数
<pre class="brush:python;toolbar:false;">
nums = [1, 3, 5, 2, 4]
print(len(nums))


结果:
>>>
5
>>>
</pre>




这段代码的的结果是?  4
<pre class="brush:python;toolbar:false;">
letters = ["a", "b", "c"]
letters.append("d")
print(len(letters))
</pre>
[space]

List 函数

insert 方法比较像 append,它允许你在列表中的任何位置插入一个新的项目，而不是只在最后一个位置
<pre class="brush:python;toolbar:false;">
words = ["Python", "fun"]
index = 1
words.insert(index, "is")
print(words)


结果：
>>>
['Python', 'is', 'fun']
>>>
</pre>

这段代码的运行结果是? 7
<pre class="brush:python;toolbar:false;">
nums = [9, 8, 7, 6, 5]
nums.append(4)
nums.insert(2, 11)
print(len(nums))
</pre>
[space]




The index method finds the first occurrence of a list item and returns its index.
If the item isn't in the list, it raises a ValueError.
<p>
index方法查找列表 第一个出现的项目并返回其索引。</p>

<p>如果项不在列表中，则会引发ValueError。</p>
<pre class="brush:python;toolbar:false;">
letters = ['p', 'q', 'r', 's', 'p', 'u']
print(letters.index('r'))
print(letters.index('p'))
print(letters.index('z'))

结果:
>>>
2
0
ValueError: 'z' is not in list
>>> 
</pre>
这里有一些关于列表list有用的方法
<p>
max(list): 返回列表中最大的值</p> 
<p>min(list): R返回列表中最小的值</p> 
<p>list.count(obj): 返回一个项目在列表中出现的次数</p> 
<p>list.remove(obj): 从列表中删除一个项目</p> 
<p>list.reverse(): 翻转列表中的项目</p> 


rag and drop from the options below to add 'z' to the end of the list and print the list's length.

list.append ('z')
print( len (list)  )

len insert index append (list)


Range

<p> range 函数 创建一个 有序的数字列表  </p>
<p> 面的代码生成一个0到10的整数列表。</p>
<pre class="brush:python;toolbar:false;">
numbers = list(range(10))
print(numbers)
 

结果：
>>>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
</pre>
<div class="tip">
列表的调用是必需的，因为range本身创建了一个范围对象，如果您想将它作为一个对象，则必须将其转换为列表。
</div>




下面代码的结果是? 4
<pre class="brush:python;toolbar:false;">
nums = list(range(5))
print(nums[4])
</pre>
[space]



Range
<p>
如果range只有一个参数，它将产生一个0到参数的列表</p></p>
<p>如果range有两个参数，它将产生一个从一个参数到第二个参数的值的列表</p>
例如：
<pre class="brush:python;toolbar:false;">
numbers = list(range(3, 8))
print(numbers)

print(range(20) == range(0, 20))


结果：
>>>
[3, 4, 5, 6, 7]

True
>>>
</pre>

这段代码的结果是 3
nums = list(range(5, 8))
print(len(nums))
[space]


Range

range 也可以有第三个参数, 它决定所产生的序列的间隔。这第三个参数必须是整数。
<pre class="brush:python;toolbar:false;">
numbers = list(range(5, 20, 2))
print(numbers)
Try It Yourself

Result:
>>>
[5, 7, 9, 11, 13, 15, 17, 19]
>>>

</pre>


这段代码的运行几个是? B
<pre class="brush:python;toolbar:false;">
nums = list(range(3, 15, 3))
print(nums[2])
</pre>
12
9
3
0





循环  
<p>有时，您需要在列表中的每个项目上执行代码。这叫做迭代，它可以用while循环和计数器变量来完成。

例如：
</p>
<pre class="brush:python;toolbar:false;">
words = ["hello", "world", "spam", "eggs"]
counter = 0
max_index = len(words) - 1

while counter <= max_index:
   word = words[counter]
   print(word + "!")
   counter = counter + 1 
 
结果：
>>>
hello!
world!
spam!
eggs!
>>>
</pre>
<div class="tip">上面的示例 遍历列表中的所有项，使用它们的索引访问它们，并用感叹号打印它们。</div>


下面哪个选项可以迭代列表 A

Loops
Variable assignment
if statements




for Loop

<p>
使用while循环迭代列表需要相当多的代码，因此Python提供了for循环作为完成相同事情的快捷方式。

前面的示例中的相同代码可以用for循环编写，如下：</p>
<pre class="brush:python;toolbar:false;">
words = ["hello", "world", "spam", "eggs"]
for word in words:
  print(word + "!")

结果：
>>>
hello!
world!
spam!
eggs!
>>>
</pre>
<div class="tip">
for循环相当于其他编程语言里面的foreach
</div>



填空创建一个正确的循环 for in ：

letters = ['a', 'b', 'c']
[space] i [space] letters:
    print（i）



for Loops
<p>for循环通常用于重复一定次数的一些代码。这是通过结合具有范围对象的循环来完成的。</p>
<pre class="brush:python;toolbar:false;">
for i in range(5):
  print("hello!")

结果：
>>>
hello!
hello!
hello!
hello!
hello!
>>>
</pre>
<div class="tip">
当在for循环中使用时，不需要调用范围对象的列表，因为它没有被索引，所以不需要列表。
</div>


填空创建一个for循环并打印偶数 for 2 i


[space] i in range（0,20,[space]):
    print([space])



Creating a Calculator

This lesson is about an example Python project: a simple calculator. 
Each part explains a different section of the program. 
The first section is the overall menu. This keeps on accepting user input until the user enters "quit", so a while loop is used.
while True:
   print("Options:")
   print("Enter 'add' to add two numbers")
   print("Enter 'subtract' to subtract two numbers")
   print("Enter 'multiply' to multiply two numbers")
   print("Enter 'divide' to divide two numbers")
   print("Enter 'quit' to end the program")
   user_input = input(": ")

   if user_input == "quit":
      break
   elif user_input == "add":
      ...
   elif user_input == "subtract":
      ...
   elif user_input == "multiply":
      ...
   elif user_input == "divide":
      ...
   else:
      print("Unknown input")

The code above is the starting point for our program. It accepts user input, and compares it to the options in the if/elif statements.
The break statement is used to stop the while loop, in case the user inputs "quit".





If we were to replace the break statement in the code with a 'continue', what would happen? B


It would run in the same way
It would run forever
You would have to enter "quit" twice to exit




Creating a Calculator

The next part of the program is getting the numbers the user wants to do something with. 
The code below shows this for the addition section of the calculator. Similar code would have to be written for the other sections.
elif user_input == "add":
  num1 = float(input("Enter a number: "))
  num2 = float(input("Enter another number: "))

Now, when the user inputs "add", the program prompts to enter two numbers, and stores them in the corresponding variables.
As it is, this code crashes if the user enters a non-numeric input when prompted to enter a number. We will look at fixing problems like this in a later module.



Why are the calls to float necessary in the code? C


To check if user input is a number
To remove spaces from user input
To convert user input to a float



eating a Calculator

The final part of the program processes user input and displays it. 
The code for the addition part is shown here.
elif user_input == "add":
  num1 = float(input("Enter a number: "))
  num2 = float(input("Enter another number: "))
  result = str(num1 + num2)
  print("The answer is " + result)

We now have a working program that prompts for user input, and then calculates and prints the sum of the input.
Similar code would have to be written for the other branches (for subtraction, multiplication and division).
The output line could be put outside the if statements to omit repetition of code.



Fill in the blanks to make the calculator work for multiplication. float * result

elif user_input == "multiply":
  num1 = float(input("Enter a number: "))
  num2 = [space] (input("Enter another number: "))
  result = str(num1 [space] num2)
  print("The answer is " + [space] )

--------------

这段代码的结果是? 8
<pre class="brush:python;toolbar:false;">
list = [1, 1, 2, 3, 5, 8, 13]
print(list[list[4]])
</pre>
[space]



这段代码的作用的hi? B
for i in range(10):
  if not i % 2 == 0:
    print(i+1)

打印1到9的基数
打印2到10的偶数
打印0到8的偶数




这段代码输出多少行?
while False:
  print("Looping...")

1
0
Infinitely many


如果元素包含偶数元素，则填充空白以打印列表的第一个元素。. len : 0

list = [1, 2, 3, 4]
if [space] (list) % 2 == 0 [space] 
 print(list[[space]])
  


这段代码输出结果是? Y

<pre class="brush:python;toolbar:false;">
letters = ['x', 'y', 'z']
letters.insert(1, 'w')
print(letters[2])
</pre>
[space]


填空，用for循环遍历列表并打印其值    for in var

list = [1, 2, 3]
[space] var [space] list
	print([space])


--------------------------------------

代码复用

<p>
代码重用是任何语言编程的一个非常重要的部分。代码大小的增加使得维护更加困难。</p><p>

对于一个大型的项目来说，要成功，必须遵守不要重复自己的原则。我们已经看到了这样做的一种方法：使用循环。在这个模块中，我们将进一步探讨两个功能和模块。
</p>


<div class="tip">
<p>
WET原则  (write everything twice)。
</p>
DRY 原则（Don't repeat yourself）不做重复的事
</div>


遵循DRY原则使代码？: A

易于维护
重复性差
永远循环

Functions-函数

<div>你已经在以前的课程中使用过函数。<br>

任何由一个单词组成的语句，在括号中的信息后面是一个函数调用。<br>

下面是一些你已经看到的例子：</div>
<pre class="brush:python;toolbar:false;">
print("Hello world!")
range(2, 20)
str(12)
range(10, 20, 3)
</pre>
<div class="tip">
括号前面的单词是函数名，括号内逗号分隔的值是函数参数。
</div>

函数调用中有多少个参数 3
range(0, 100, 5)  
[space]



Functions
<div>
除了使用预定义函数外，还可以使用def语句创建自己的函数。<br>

下面是一个名为MyuFunc的函数的例子。它不需要任何参数，并打印“spam”三次。它被定义，然后被调用。函数中的语句只有在调用函数时才执行。<br>
</div>

<pre class="brush:python;toolbar:false;">
def my_func():
   print("spam")
   print("spam")
   print("spam")

my_func()

 结果：
>>>
spam
spam
spam
>>>
</pre>
<div class="tip">
每个函数中的代码块以冒号（：）开头并缩进。</div>


填空，定义一个名为Hello的函数： def :  
 
[space] hello()[space]
  rint("Hi!")


  Functions-调用顺序

必须在调用函数之前定义函数，就像在使用它们之前必须指定变量一样。
<pre class="brush:python;toolbar:false;">
hello()

def hello():
    print("Hello world!")
Try It Yourself

结果
>>>
NameError: name 'hello' is not defined
# hello没有被定义
>>>
</pre>

重新排列代码以声明函数sayy（）并调用它。

def sayHi():
   print("Hi!")
sayHi()


Arguments（参数）
<div>
到目前为止，我们所看到的所有函数定义都是零参数的函数，这些函数用空括号调用。<br>
然而，大多数函数采用参数。<br>
下面的示例定义了一个函数，该函数采用一个参数：
</div>
<pre class="brush:python;toolbar:false;">
def print_w(word):
   print(word + "!")
    
print_w("spam")
print_w("eggs")
print_w("python")

>>>
spam!
eggs!
python!
>>>
</pre>
<div class="tip">
正如你所看到的，这个参数是在括号内定义的。
</div>



这个代码的结果是什么？ 6
<pre class="brush:python;toolbar:false;">
def p_double(x):
   print(2 * x)

p_double(3)
</pre>
[space]

Arguments-多个参数

您还可以定义具有多个参数的函数；用逗号分隔它们。
<pre class="brush:python;toolbar:false;">
def print_sum_twice(x, y):
   print(x + y)
   print(x + y)

print_sum_twice(5, 8)

结果：
>>>
13
13
>>>
</pre>


填充空白以定义一个函数，该函数使用两个参数并打印它们的乘积。 def,:,y

  
 
 [space]print_mult(x, y)[space]
  
 

   print(x * [space])

<!-- 
函数参数can be used as the function定义变量里面。但是，他们不能在这项工作的最后一段最后确定。这也适用于其他变数。

Fill in the blanks to define a function that prints "Yes", if its parameter is an even number, and "No" otherwise. def,print,else:

  
 
 [space]even(x):
   if x%2 == 0:   
   [space]("Yes")
   [space]  
   print("No")

 -->

   函数返回值

<div>
某些函数，如int或str，返回一个可以在以后使用的值。

要为定义的函数这样做，可以使用返回语句。
</div>

例如：<br>
<pre class="brush:python;toolbar:false;">
def max(x, y):
    if x >=y:
        return x
    else:
        return y
        
print(max(4, 7))
z = max(8, 5)
print(z)


结果：
>>>
7
8
>>>
</pre>
<div class="tip">
return语句不能在函数定义之外使用。
</div>



填充空白，定义一个函数，比较其参数的长度并返回最短的一个。 len,return,return

def shortest_string(x, y):
  if len(x) <= [space](y):
  	[space] x
  else:
  	[space]y


函数返回值

一旦从函数返回一个值，它就立即停止执行。返回语句后的任何代码都不执行。<br>
如：
<pre class="brush:python;toolbar:false;">
def add_numbers(x, y):
  total = x + y
  return total
  print("这个将不会被打印")

print(add_numbers(4, 5))

结果
>>>
9
>>>
</pre>

这个函数打印的最高数目是多少？ 2
<pre class="brush:python;toolbar:false;">
def print_num():
  print(1)
  print(2)
  return
  print(4)
  print(6)
</pre>
 [space]
 Comments（注释）

<p>注释是用于使代码更容易理解的注释。它们不影响代码的运行方式。</p>
<p>在 Python,通过插入一对"""来创建注释。 (或者用 #创建一个单行注释). </p>

举个例子:
<pre class="brush:python;toolbar:false;">
x = 365
y = 7
# 这是个注释

print(x % y) # find the remainder
# print (x // y)
# 另外一个注释
 
结果：
>>>
1
>>>
<pre>
<div class="tip">
Python没有像C语言一样通用的多行注释，
</div>

Python doesn't have general purpose multiline comments, as do programming languages such as C.



填空注释文本: #

x = 8 
[space]printing x
print(x)


文档字符
文档字符 他们是设计来解释代码。然而，他们有更多的特异性和不同的语法。他们通常放在函数的第一行，由多行字符串解释下面的函数。
<pre class="brush:python;toolbar:false;">
def shout(word):
  """
  打印字符并在后面加上感叹号
  """
  print(word + "!")
    
shout("spam")


结果：
>>>
spam!
>>>
</pre>
<div class="tip">
与常规注释不同，文档串在程序的运行时被保留。这允许程序员在运行时检查这些注释。
</div>



文档字符串可以包含多行文本吗？ B

No
Yes


Functions-函数重新赋值

虽然函数与正常变量不同，但函数和任何其他类型的值一样。<br>

它们可以被赋值并重新赋值给变量，然后由这些名称引用。
<pre class="brush:python;toolbar:false;">
def multiply(x, y):
   return x * y

a = 4
b = 7
ope = multiply
print(ope(a, b))

结果
>>>
28
>>>
</pre>
<div class="tip">上面的示例将函数赋给一个变量操作。现在，名称ope也可以用来调用函数。
</div>



这个代码的输出是多少？ c
<pre class="brush:python;toolbar:false;">
def shout(word):
   return word + "!"
speak = shout
output = speak("shout")
print(output)
</pre>
word!
speak!
shout!



Functions

函数也可以用作其他函数的参数。
<pre class="brush:python;toolbar:false;">
def add(x, y):
  return x + y

def do_twice(func, x, y):
  return func(func(x, y), func(x, y))

a = 5
b = 10

print(do_twice(add, a, b))


结果：
>>>
30
>>>
</pre>
<div class="tip">正如您所看到的，函数do_twice两次将函数作为参数，并调用它的主体。</div>



填空，把函数“square”作为函数“test”的一个参数。: def,square,:

  
 
[space]square(x):
  return x * x

def test(func, x):
  print(func(x))

test([space], 42)



Modules(模块)

模块是其他人编写的用于完成共同任务的代码，例如生成random 模块用来生成随机数。<br>
使用模块的基本方法是在代码顶部添加导入模块名（import module_name），然后使用（module_name.变量名）访问模块中具有名称的函数和值<br>
例如，下面的示例使用随机模块生成随机数： <br>
<pre class="brush:python;toolbar:false;">
import random

for i in range(5):
   value = random.randint(1, 6)
   print(value)

结果:
>>>
2
3
6
5
4
>>>
</pre>
<div class="tip">代码使用随机模块中定义的randint函数在范围1到6范围内打印5个随机数。
</div>





在这个代码中使用哪个模块？ B
<pre class="brush:python;toolbar:false;">
import math
num = 10
print (math.sqrt(num))
</pre>

sqrt
math
num



Modules

如果您只需要某个模块的某些功能，就可以使用另一种导入。
These take the form from module_name import var, and then var can be used as if it were defined normally in your code. 
使用 （from 模块名 import 变量名） 然后可以使用变量名，就像它在代码中被正常定义一样。
例如，只从数学模块导入π常量：
<pre class="brush:python;toolbar:false;">
from math import pi

print(pi)
Try It Yourself

结果
>>>
3.141592653589793
>>>
</pre>
<div class="tip">
使用逗号分隔导入多个 项目.如: <br> 
from math import pi, sqrt
</div>


<div class="tip">
* 使用*符号导入所有的内容. 如: from math import *<br>
这通常是不被鼓励的，因为容易将代码中的变量与外部模块中的变量混淆。
</div>




填空空只从math模块导入cos 和sqrt项目 from,sqrt,&#45; 
[space] math import [space] sqrt
 

 Modules
试图导入一个不可用的模块会导致导入错误。
<br>
例如：<br>

<pre class="brush:python;toolbar:false;">
import some_module

Result:
>>>
ImportError: No module named 'some_module'
>>>
</pre>

导入未知模块会导致什么错误？ C

UnknownModuleError
ModuleError
ImportError


Modules

可以使用as关键字在不同的名称下导入模块或对象。这主要是在模块或对象具有冗长或混淆的名称时使用。<br>
如：<br>
<pre class="brush:python;toolbar:false;">
from math import sqrt as square_root
print(square_root(100))
Try It Yourself

结果:
>>>
10.0
>>>
</pre>



这个代码的输出是多少？ B
import math as m
print(math.sqrt(25))

5
An error occurs
25


---------------
Modules
<p>

Python中有三种主要类型的模块。, 你自己编写的那些，你从外部源安装的，以及那些用Python预装的。
</p><p>
最后一种类型称为标准库。 包含许多有用的模块. 包括string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest, unittest, pdb, argparse and sys.
</p><p>
标准库可以完成的任务包括字符串解析、数据序列化、测试、调试和操作日期、电子邮件、命令行参数等等。</p>
<p>Python广泛的标准库是它作为语言的主要优点之一。</p>


填充空白以导入数学模块。   import

  
 
 [space]math


 


标准库

标准库中的一些模块是用Python编写的，有些是用C语言编写的。
<p>多数都可在所有平台上使用，但有些是Windows或UNIX专用的。</p>
<p>我们不会讲解标准库中的所有模块，太多了。标准库的完整文档可在www. Python .Org网上获得。</p>



Python预装模块的名称是什么？ D

import
Unix
The Standard Library（标准模块）






Modules

许多第三方Python模块存储在Python包索引上。(PyPI). 
<p>好的安装方法是使用一个叫做PIP的程序。默认情况下，它是用Python的现代发行版安装的。如果你没有，它很容易在线安装。一旦拥有了，从PyPI安装库就很容易了。查找要安装的库的名称，转到命令行（对于Windows，它将是命令提示符），并输入PIP安装库名称。完成此操作后，导入库并在代码中使用它。</p>

<p>使用PIP是在大多数操作系统上安装库的标准方式，但是一些库具有用于Windows的预构建二进制文件。这些都是正常的可执行文件，允许您安装GUI的库，就像安装其他程序一样。

在命令行输入PIP命令很重要，而不是Python解释器。</p>


PyPI代表什么？? B

Python Project Index
Python Package Index
Python Package Installer



填空，定义一个函数，将两个数作为参数并返回较小的函数。 def,:,return

  
 
 [space]min(x, y):  
  if x<=y[space]
    return x
  else:
  	[space] y


 Rearrange the code to define a function that calculates the sum of all numbers from 0 to its argument.

  return res
  for i in range(x):
def sum(x):
    res += i
  res = 0
 


 如果要使用rrandint 函数，你会如何引用它？ B
from random import randint as rnd_int

random.rnd_int
randint
rnd_int
    


这个代码的最大输出量是多少？  0
<pre class="brush:python;toolbar:false;">
def print_nums(x):
  for i in range(x):
    print(i)
    return
print_nums(10)
</pre>
[space]

这个代码的输出是多少？ 6
<pre class="brush:python;toolbar:false;">
def func(x):
  res = 0
  for i in range(x):
     res += i
  return res

print(func(4))
</pre>

[space]
  

  ------------
  异常
  <div>已经在以前的代码中看到了异常。由于错误的代码或输入，出错时会发生。当发生异常时，程序立即停止。<br>
下面的代码通过尝试将7除以0来生成ZeroDivisionError 异常。</div>

<pre class="brush:python;toolbar:false;">
num1 = 7
num2 = 0
print(num1/num2)
结果是：
ZeroDivisionError: division by zero
</pre>

什么是异常？ c
函数
变量
由于错误的代码或输入而发生的事件。

  意外
  <div>
由于不同的原因，提出了不同的例外。<br>

常见例外：
ImportError：导入失败；
IndexError：一个列表用一个超出范围的数字索引；<br>
NameError：使用未知变量；<br>
SyTraceError：无法正确解析代码；<br>
TypeError：在不适当类型的值上调用函数；<br>
ValueError：函数被调用在正确类型的值上，但具有不适当的值。<br>
  </div>
<div class="tip">Python有几个其他内置异常，例如ZooDistVistIOrror和OsCurror。第三方库也经常定义它们自己的异常。</div>

这个代码引发了什么异常？

print（“7”+ 4） A
TypeError
ZeroDivisionError
ValueError


异常处理
<div>要处理异常，并在发生异常时调用代码，则可以使用“try/except ”语句。

尝试块包含可能引发异常的代码。如果发生异常，则尝试执行块中的代码，并运行除块中的代码。如果没有发生错误，除块中的代码不会运行。
</div>

例如：<br>
<pre class="brush:python;toolbar:false;">
try:
   num1 = 7
   num2 = 0
   print (num1 / num2)
   print("Done calculation")
except ZeroDivisionError:
   print("An error occurred")
   print("due to zero division")


结果:
>>>
An error occurred
due to zero division
>>>
</pre>
<div class="tip">在上面的代码中，定义了要处理的异常类型
</div>


这个代码的输出是多少？ C
<pre class="brush:python;toolbar:false;">
try:
  variable = 10
  print (10 / 2)
except ZeroDivisionError:
  print("错误")
print("完成")
 </pre>
 错误 完成
5.0
5.0 完成

异常处理
<p>

尝试语句可以有多个不同的块，以处理不同的异常。<br>

也可以使用括号将多个异常放入一个单独的块中，使除块处理所有的异常。</p>


<pre class="brush:python;toolbar:false;">
try:
   variable = 10
   print(variable + "hello")
   print(variable / 2)
except ZeroDivisionError:
   print("Divided by zero")
except (ValueError, TypeError):
   print("Error occurred")

结果：
>>>
Error occurred
>>>
</pre>

这个代码的输出结果是什么？
<pre class="brush:python;toolbar:false;">
try:
  meaning = 42
  print(meaning / 0)
  print("the meaning of life")
except (ValueError, TypeError):
  print("ValueError or TypeError occurred")
except ZeroDivisionError:
  print("Divided by zero")</pre>

  ValueError or TypeError occurred
Divided by zero ValueError or TypeError occurred
Divided by zero



异常处理
<p>指定的例外语句将捕获所有错误。这些方法应谨慎使用，因为它们可以捕捉意外错误并隐藏编程错误。</p>
例如:
<pre class="brush:python;toolbar:false;">
try:
   word = "spam"
   print(word / 0)
except:
   print("An error occurred")
Try It Yourself

Result:
>>>
An error occurred
>>></pre>
<div class="tip">异常处理在处理用户输入时特别有用。</div>




在空白处处理所有可能的异常情况。 try:,except:

[space]
 num1 = input(":")
  num2 = input(":")
  print(float(num1)/float(num2))
[space]
  print("Invalid input")


  finally
  <div>为了确保某些代码运行，不管发生什么错误，都可以使用最终语句。最后一个语句被放置在一个尝试try/except语句的底部。最后语句中的代码总是在try中执行代码后运行，也可能在except中执行。</div>
  <pre class="brush:python;toolbar:false;">
try:
   print("Hello")
   print(1 / 0)
except ZeroDivisionError:
   print("0不能做分母")
finally:
   print("这条代码运行是必须的")

   结果：

   >>>
Hello
0不能做分母
这条代码运行是必须的
>>>
  </pre>


  这段代码的输出结果是：C
  <pre class="brush:python;toolbar:false;">
try:
  print(1)
except:
  print(2)
finally:
  print(3)
  </pre>
3
1
1 3
1 2 3


finally 语句中的代码即使在前面一个块中未发生异常时也会运行。

<pre class="brush:python;toolbar:false;">
try:
   print(1)
   print(10 / 0)
except ZeroDivisionError:
   print(var)
finally:
   print("最终被执行")

结果：
>>>
1
最终被执行

ZeroDivisionError: division by zero
During handling of the above exception, another exception occurred
NameError: name 'var' is not defined
（在处理上面错误时候，另一个错误发生，
名称错误：没有var 没有定义过）
>>>
</pre>

创建一个try/except/finally 代码库
[space]
  print(1)
[space]
  print(2)
[space]
  print(42)


  抛出异常
  可以使用 raise语句来抛出异常。
  <pre  class="brush:python;toolbar:false;">
print(1)
raise ValueError
print(2)

结果
>>>
1
ValueError
>>>
  </pre>
<div class="tip">您需要指定引发异常的类型。</div>


在执行此代码时发生哪些错误？ B

<pre  class="brush:python;toolbar:false;">
try:
  print(1 / 0)
except ZeroDivisionError:
  raise ValueError</pre>


ValueError
ZeroDivisionError and ValueError
none
ZeroDivisionError

异常
可以用给出详细信息的参数来引发异常。<br>

例如：
<pre class="brush:python;toolbar:false;">
name = "123"
raise NameError("Invalid name!")

结果：
>>>
NameError: Invalid name!
>>>
</pre>


如果输入为负值，填充以引发ValueError异常。 <,raise
num = input(":")
if float(num)[space]0:
  [space] ValueError("Negative!")

异常


在type/except块中，可以使用不带参数的提升语句重新引发任何异常。<br>

例如：
<pre class="brush:python;toolbar:false;">
try:
   num = 5 / 0
except:
   print("一个错误发生")
   raise
 
结果：
>>>
一个错误发生

ZeroDivisionError: division by zero
>>>
</pre>


可以在 except语句外用 raise语句吗？ A
Yes
No


Assertions断点
断点是一种明智的检查，当您完成程序测试时，您可以打开或关闭。<br>

测试表达式，如果结果为false，则引发异常。<br>

断点是通过使用断点语句来执行的。<br>

<pre class="brush:python;toolbar:false;">
print(1)
assert 2 + 2 == 4
print(2)
assert 1 + 1 == 3
print(3)
Try It Yourself

结果:
>>>
1
2
AssertionError
>>>
</pre >
<div class="tip">程序员通常在函数的开始处设置断点以检查有效输入，并在函数调用之后检查有效输出。</div>


这个代码打印的最高数字是多少？1

<pre class="brush:python;toolbar:false;">
print(0)
assert "h" != "w"
print (1)
assert False
print(2)
assert True
print(3)
</pre>
[space]

Assertions
断点可以采取第二个参数，如果断点失败，则传递给断点错误。

<pre>
temp = -10
assert (temp >= 0), "在0以下！"
Try It Yourself

结果
>>>
AssertionError: 在0以下！
>>>
</pre>
<div class="tip">AssertionError异常可以像使用 try-except 语句一样捕获和处理任何其他异常，但是如果没有处理，这种类型的异常将终止程序。</div>

填充空白以定义一个函数，该函数采用一个参数。断言论点是积极是的。 def,assert
[space] my_func(x):
  [space] x > 0, "Error!"
  print(x)

----
打开文件
<div>你可以使用Python来读取和写入文件的内容。<br>

文本文件是最容易操作的。在可以编辑文件之前，必须使用Open函数打开文件。</div>

<pre class="brush:python;toolbar:false;">myfile = open("filename.txt")</pre>
<div class="tip">
打开函数的参数是文件的路径。如果文件在程序的当前工作目录中，则只能指定其名称。
</div>
 
哪个函数用于访问文件？open
[space]

open 第二个参数
<div>可以通过向打开函数应用第二个参数指定用于打开文件的模式。<br>

发送“R”意味着在读取模式下打开，这是默认的。<br>

发送“W”意味着写入模式，用于重写文件的内容。<br>

发送“A”意味着追加模式，将新内容添加到文件的末尾。<br>



在模式中添加“B”以二进制模式打开它，它用于非文本文件（如图像和声音文件）。<br>

例如：</div>
<pre class="brush:python;toolbar:false;">
# 写入模式
open("filename.txt", "w")

# 只读模式
open("filename.txt", "r")
open("filename.txt")

# 二进制写入模式
open("filename.txt", "wb")
</pre>

从下面的选项中拖放，以二进制读取模式打开一个名为“Test.bin”的文件。text.bin,rb

file = open([space],[space])

打开文件-关闭资源
一旦一个文件被打开和使用，你就应该关闭它。<br>

这是用文件对象的 close 方法完成的。
<pre>
file = open("filename.txt", "w")
# 对文件进行处理
file.close()


</pre>
<div class="tip">我们将在即将到来的课程中read/write内容。</div>

如何关闭存储在变量“text_file”中的文件？A
text_file.close()
close("text_file")
close(text_file)

Reading Files写入文件
可以使用read方法读取打开的文件的内容。

<pre class="brush:python;toolbar:false;">
file = open("filename.txt", "r")
cont = file.read()
print(cont)
file.close()</pre>
<div class="tip">
这将打印文件“filename.txt”的所有内容。</div>


重新排列代码以打开文件，读取其内容，打印它们，然后关闭文件。


file = open("test.txt")
cont = file.read()
print(cont)
file.close()

读文件
<div>若要读取特定数量的文件，可以向读取函数提供一个参数作为参数。这决定了应该读取的字节数。<br>

您可以在同一个文件对象上进行更多的调用，以逐字节读取文件的更多内容。在没有参数的情况下，Read返回文件的其余部分。</div>
<pre class="brush:python;toolbar:false;">
file = open("filename.txt", "r")
print(file.read(16))
print(file.read(4))
print(file.read(4))
print(file.read())
file.close()
</pre>



如果一个字符是一个字节，这个代码打印的每行有多少个字符？ 4
<pre  class="brush:python;toolbar:false;">
file = open("filename.txt", "r")
for i in range(21):
  print(file.read(4))
file.close()
</pre>
[space]

Reading Files
<p>在读取文件中的所有内容之后，任何试图从该文件中读取的内容都会返回一个空字符串，因为您正试图从文件的末尾读取。</p>
<pre class="brush:python;toolbar:false;">
file = open("filename.txt", "r")
file.read()
print("Re-reading")
print(file.read())
print("Finished")
file.close()

结果:
>>>
Re-reading

Finished
>>>
</pre>

填空，打开一个文件，读取它的内容并打印它的长度。 open,read
file = [space] ("filename.txt", "r")
str = file.[space]()
print(len(str))
file.close()


读取一行
<div>若要检索文件中的每一行，可以使用readlines方法返回一个列表，其中每个元素都是文件中的一行。</div>例如：
<pre class="brush:python;toolbar:false;">
file = open("filename.txt", "r")
print(file.readlines())
file.close()

结果
>>>
['Line 1 text \n', 'Line 2 text \n', 'Line 3 text']
>>>
</pre>
<p>您还可以使用for循环来迭代文件中的行：</p>

<pre class="brush:python;toolbar:false;">
file = open("filename.txt", "r")

for line in file:
    print(line)

file.close() 

例子
>>>
Line 1 text

Line 2 text

Line 3 text
>>></pre>
<div class="tip">在输出中，行由空白行分隔，因为打印功能在其输出端自动添加新的行</div>

如果文件test.txt有7行内容，下面的表达式将返回什么？7
len(open("test.txt").readlines())
[space]


写入文件
<div>要写入文件，您需要使用write方法，该方法将字符串写入文件。
<br>
例如：</div>

<pre class="brush:python;toolbar:false;">
file = open("newfile.txt", "w")
file.write("写入字符串在文件里")
file.close()

file = open("newfile.txt", "r")
print(file.read())
file.close()


结果
>>>
写入字符串在文件里
>>></pre>

<div class="tip">“W”模式将创建一个文件，如果它还不存在。</div>

哪一行代码将“Hello World！”写入一个文件？

write("Hello world!", file)
file.write("Hello world!")
write(file, "Hello world!")

写入
<p>当文件以写模式打开时，文件的已有内容被删除</p>

<pre class="brush:python;toolbar:false;">
file = open("newfile.txt", "r")
print("初始化读写内容")
print(file.read())
print("完成")
file.close()

file = open("newfile.txt", "w")
file.write("新的内容")
file.close()

file = open("newfile.txt", "r")
print("写入新的内容")
print(file.read())
print("结束")
file.close()

结果
>>>
初始化读写内容
一些预先内容
结束
写入新的内容
新的内容
结束
>>>
</pre>

<div class="tip">
正如你所看到的，文件的内容已经被改写了。</div>

如果以写模式打开文件，然后立即关闭文件会发生什么？ C
没有变化
一行空白写入文件
删除原文件内容

写入字节数
<div>如果成功，则write方法返回写入文件的字节数。</div>
<pre class="brush:python;toolbar:false;">
msg = "Hello world!"
file = open("newfile.txt", "w")
amount_written = file.write(msg)
print(amount_written)
file.close()
Try It Yourself

Result:
>>>
12
>>>
</pre>

如果文件写入操作成功，这些语句中的哪一个将是真的？

file.write(msg) == len(msg)
file.write(msg) == True
file.write(msg) == msg


使用文件
<div>当使用文件后，总是用close关闭 是一种好的喜欢。通常会和 try and finally结合使用</div>
<pre  class="brush:python;toolbar:false;">
try:
   f = open("filename.txt")
   print(f.read())
finally:
   f.close()
</pre>
<div class="tip">

这确保文件始终关闭，即使发生错误。</div>

这段代码是否调用了closse A
<pre class="brush:python;toolbar:false;">
try:
  f = open("filename.txt")
  print(f.read())
  print(1 / 0)
finally:
  f.close()
</pre>
调用了
没有


Working with Files

这样做的另一种方法是使用with语句。这将创建一个临时变量（通常称为F），该变量只能在带语句的缩进块中访问。
<pre class="brush:python;toolbar:false;">
with open("filename.txt") as f:
   print(f.read())
</pre>
<div class="tip">即使在语句中出现异常，文件也会自动在结束语句结束时关闭。</div>


填写空白，创建一个有效的语句，读取文件的内容。with,as,read
[space]open("test.txt")[space] f:
print(f.[space]())


这个代码不打印哪个号码？B

<pre class="brush:python;toolbar:false;">
try:
  print(1)
  print(20 / 0)
  print(2)
except ZeroDivisionError:
  print(3)
finally:
  print(4)


</pre>

3
2
4

以二进制写模式打开文件。b
open("test.txt", "w[space]")

填空，尝试从文件中打开和读取。在异常情况下打印错误消息。 with,f,except:
try:
  [space] open("test.txt") as[space]:
  print(f.read())
[space]
   print("Error")

这个代码打印的最大数字是多少？3
<pre class="brush:python;toolbar:false;">
try:
  print(1)
  assert 2 + 2 == 5
except AssertionError:
  print(3)
except:
  print(4)


</pre>
[space]



None


<div>
“None”对象用于表示值的缺失。<br>
在其他编程语言中，它类似于NULL。<br>
与其他“空”值（如0、[]）和空字符串一样，当转换为布尔变量时，值为False。<br>
当输入到Python控制台时，它显示为空字符串。<br>
</div>
<pre class="brush:python">
>>> None == None
True
>>> None
>>> print(None)
None
>>>
</pre>



“None”经常用来表示什么？ B
一个错误的值（False）
没有赋值
无效值


None
函数没有返回值，默认返回“None”

<pre class="brush:python">
def some_func():
  print("Hi!")

var = some_func()
print(var)

结果：
>>>
Hi!
None
>>>
</pre>



这个代码打印什么数字？1
<pre class="brush:python">
foo = print()
if foo == None:
   print(1)
else:
   print(2)
</pre>
[space]


字典
<div>
字典是用于将任意键映射到值的数据结构。<br>
列表可以被认为是具有一定范围内的整数键的字典。<br>
字典可以用与列表相同的方式索引，使用包含键的方括号。
</div>
例如：
<pre class="brush:python">
ages = {"Dave": 24, "Mary": 42, "John": 58}
print(ages["Dave"])
print(ages["Mary"])

结果：
>>>
24
42
>>>
</pre>
<div class="tip">字典中的每个元素都由键：值对表示。</div>

在空白中定义具有两个元素的有效字典。:,}
cars = {"BMW"[space]"blue", "Volvo": "red"[space]
  
字典
<div>试图索引不是词典的一部分的键返回键错误。</div>
例如：<br>
<pre class="tip">
primary = {
  "red": [255, 0, 0], 
  "green": [0, 255, 0], 
  "blue": [0, 0, 255], 
}

print(primary["red"])
print(primary["yellow"])

结果：
>>>
[255, 0, 0]

KeyError: 'yellow'
>>>
</pre>
<div class="tip">字典的值可以存储任何类型</div>
<div class="tip">用{}定义一个空的字典</div>


这个代码的结果是什么？B
<pre class="brush:python">
test = { }
print(test[0])
</pre>


0
KeyError
None

字典
<div>
只有不可变的对象可以用作字典的键。不可变的对象是不能改变的对象。<br>
到目前为止，你遇到的唯一可变对象是列表和字典(lists 和 dictionaries )。<br>
尝试使用可变对象作为字典键会导致类型错误。<br>

</div>

<pre class="brush:python">
bad_dict = {
  [1, 2, 3]: "one two three", 
}

结果:
>>>
TypeError: unhashable type: 'list'
>>>
</pre>

这些值中的哪一个不能用作字典键？ A

{2: 4, 3: 9, 4: 16,}
"one two three"
False


字典操作

<div>就像列表一样，字典键可以被分配给不同的值。<br>
但是，与列表不同的是，新字典键也可以被赋值，而不仅仅是已经存在的值。</div>

<pre  class="brush:python">
squares = {1: 1, 2: 4, 3: "error", 4: 16,}
squares[8] = 64
squares[3] = 9
print(squares)

结果：
{8: 64, 1: 1, 2: 4, 3: 9, 4: 16}
</pre>
这段代码的结果是?
<pre class="brush:python">
primes = {1: 2, 2: 3, 4: 7, 7:17}
print(primes[primes[4]])
</pre>


字典

<p>要确定一个键是否在字典中,就像在列表中一样</p>
<pre class="brush:python">
nums = {
  1: "one",
  2: "two",
  3: "three",
}
print(1 in nums)
print("three" in nums)
print(4 not in nums)
</pre>
<p>结果</p>
<pre class="brush:python">
nums = {
  1: "one",
  2: "two",
  3: "three",
}
print(1 in nums)
print("three" in nums)
print(4 not in nums)
</pre>

如果键112出现在名为“pairs”的字典中，打印“yes”。

if 112 [space] paris：
  print("yes")

字典

字典一个一个非常好用的方法get ，如果在字典中找不到键值则返回第二参数当做默认值 <br>
<pre class="brush:python">
pairs = {1: "apple",
  "orange": [2, 3, 4], 
  True: False, 
  None: "True",
}

print(pairs.get("orange"))
print(pairs.get(7))
print(pairs.get(12345, "不在字典中") 
</pre>
<b>结果</b>
<pre class="brush:python">
>>>
[2, 3, 4]
None
不在字典中
>>>
</pre>

这段代码的结果是？
<pre class="brush:python"> 8
fib = {1: 1, 2: 1, 3: 2, 4: 3}
print(fib.get(4, 0) + fib.get(7, 5)  
</pre>
[space]

元组
<div class="explain">
Tuples元组与列表非常相似，除了它们是不可变的（它们不能被改变）。<br>
而且，它们是用括号创建的，而不是用方括号创建的。
</div>
 <p class="exa"><b>例如：<b></p>
 <pre class="brush:python">words = ("spam", "eggs", "sausages",)</pre>
 <div class="explain">你可以用索引来访问元组中的值，就像列表中的一样：</div>
 <pre class="brush:python"> print(words[0])</pre>
 <div class="explain">试图重新赋值元组中的值会导致类型错误。</div>
 <pre class="brush:python">words[1] = "cheese"</pre>
 <p class="resu"><b>结果：<b></p>
 <pre class="brush:python">
>>>
TypeError: 'tuple' object does not support item assignment
>>>
 </pre>
 <div class="tip">与列表和字典一样，元组可以嵌套在彼此之间。</div>

 填充空白以创建列表、字典和元组：

 # 列表list
list =[space]"one", "two"[sapce]

# 字典dictionary 
dict =[space]1:"one", 2:"two"[space]

# 元组tuple 
tp = [space]"one", "two"[space]

Tuples
<div class="explain">元组可以不用括号来创建，只要用逗号分隔这些值即可。</div>
 <p class="exa"><b>例如：<b></p>
 <pre class="brush:python">
my_tuple = "one", "two", "three"
print(my_tuple[0])
 </pre>
  <p class="resu"><b>结果：<b></p>
  <pre class="brush:python">
>>>
one
>>>
</pre>
<div class="explain">使用空括号对创建空元组。</div>
<pre class="brush:python">tpl = ()</pre>
<div class="tip">元组比列表快，但它们不能更改。</div>

这段代码的结果是： A
<pre class="brush:python">
tuple = (1, (1, 2, 3))
print(tuple[1])
</pre>
(1, 2, 3)
1
((1, 2, 3))


列表切片
<div class="explain">
列表切片提供了从列表中检索值的更高级方法。<br>
基本列表切片涉及用两个冒号分离的整数对列表进行索引。<br>
这会返回一个新的列表，包含索引之间旧列表中的所有值。
</div>
 <p class="exa"><b>例如：<b></p>
 <pre class="brush:python">
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[2:6])
print(squares[3:8])
print(squares[0:1])
 </pre>
  <p class="resu"><b>结果：<b></p>
  <pre class="brush:python">
>>>
[4, 9, 16, 25]
[9, 16, 25, 36, 49]
[0]
>>>
  </pre>
<div class="tip">与范围的参数一样，在切片中提供的第一个索引包含在结果中，但第二个不是。</div>


这段代码的结果是？
<pre class="brush:python">
sqs = [0, 1, 4, 9, 16, 25, 36, 49, 64]
print(sqs[4:7])
</pre>

[16, 25, 36, 49]
[16, 25, 36]
[25, 36, 49]

列表切割
<div class="explain">
如果省略了切片中的第一个数，则将其作为列表的开始。<br>

如果第二个数字被省略，则被认为是结束。
</div>
 <p class="exa"><b>例如：<b></p>
 <pre class="brush:python">
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[:7])
print(squares[7:])
 </pre>
 <p class="resu"><b>结果：<b></p>
 <pre class="brush:python">
>>>
[0, 1, 4, 9, 16, 25, 36]
[49, 64, 81]
>>>
 </pre>
 <div class="tip">切片也可以在元组上进行。</div>

 填空，取列表的前两个元素：2
 list = ["a", "b", "c", "d"]
 a = list[0[space] ]

 列表切片还可以有第三个数字，表示步进，只包括切片中的替代值。

 <pre class="brush:python">
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[::2])
print(squares[2:8:3])
 </pre>
  <p class="resu"><b>结果：<b></p>
<pre class="brush:python">
>>>
[0, 4, 16, 36, 64]
[4, 25]
>>>
</pre>
<div class="tip">
[2:8:3]将包括从第二个索引到第八个元素的元素,每次间隔6个元素
</div>

这段代码的结果是? A

sqs = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(sqs[1::4])

[1, 25, 81]
[1, 25]
An error occurs
[0, 1, 4]

列表切割负数
 
<div class="explain">负值可以用于列表切片（以及正常列表索引）。<br>当负值用于切片（或正常索引）中的第一和第二值时，它们从列表的末尾计数。</div>
<pre class="brush:python">
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[1:-1])
</pre>
 <p class="resu"><b>结果：<b></p>
 <pre class="brush:python">
>>>
[1, 4, 9, 16, 25, 36, 49, 64]
>>>
 </pre>
<div class="tip">如果该步骤使用负值，则切片向后进行。<br>

使用[：：-1 ]作为一个切片是一种常见的和习惯性的方法来反转列表。</div>

这段代码的输出结果是什么 B
<pre class="brush:python">
sqs = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(sqs[7:5:-1])
</pre>

[]
[49, 36]
[49]

列表推导式

<div class="explain">
列表理解是快速创建其内容遵循简单规则的列表的一种有用方法。<br>

例如，我们可以做到以下几点：

</div>
<pre class="brush:python">
# 列表推导式
cubes = [i**3 for i in range(5)]

print(cubes)
</pre>
 <p class="resu"><b>结果：<b></p>
 <pre class="brush:python">
>>>
[0, 1, 8, 27, 64]
>>>
 </pre>
<div class="tip">列表推导式比较像 数学里面的set-builder标记法</div>

这段代码创建了什么？ A
nums = [i*2 for i in range(10)]

0和18之间的偶数列表

0和10之间的所有数字的列表

0和10之间的偶数列表

列表推导式
<div class="explain">列表推导式可以包含if语句来强制列表中的值的条件。</div>
 <p class="exa"><b>例如：<b></p>
<pre class="brush:python">
evens=[i**2 for i in range(10) if i**2 % 2 == 0]

print(evens)
</pre>
 <p class="resu"><b>结果：<b></p>
<pre class="brush:python">
>>>
[0, 4, 16, 36, 64]
>>> 
</pre>

从0到20创建一个3倍数的列表。[,if,3

a =[space]i for i in range(20) [space]i% [space]==0]

<div class="explain">试图在非常广泛的范围内创建一个列表会导致内存错误。<br>


列表推导式
这个代码展示了一个列表理解在内存中耗尽的例子。</div>
<pre class="brush:python">even = [2*i for i in range(10**100)]</pre>
<p class="resu"><b>结果：<b></p>
<pre class="brush:python">
>>>
MemoryError
>>>
 
</pre>
填空，在5到9的范围内创建一个乘以10的数字列表。 for,in,5
a = [x*10 [space] x [space] range([space],9)]


字符串格式化
<div class="explain">
到目前为止，为了组合字符串和非字符串，您已经将非字符串转换为字符串并添加它们。<br>

字符串格式化提供了在字符串中嵌入非字符串的更强大的方法。字符串格式化使用字符串的格式方法来替换字符串中的多个参数。
</div>
<p class="exa"><b>例如：<b></p>
<pre class="brush:python">
# 字符串格式化
nums = [4, 5, 6]
msg = "Numbers: {0} {1} {2}". format(nums[0], nums[1], nums[2])
print(msg)
</pre>
<p class="resu"><b>结果：<b></p>
<pre class="brush:python">
>>>
Numbers: 4 5 6
>>>
</pre>
<div class="tip">格式化函数的每个参数都放置在相应位置的字符串中，这是使用{}确定的。</div>
这段代码的运行结果是？ abracadabra
<pre class="brush:python">
print("{0}{1}{0}".format("abra", "cad"))
</pre>
 [space]

字符串格式化
<div class="explain"> 字符串格式化也可以用命名参数来完成。</div>
<pre class="brush:python">
a = "{x}, {y}".format(x=5, y=12)
print(a)
</pre>
<p class="resu"><b>结果：<b></p>
<pre class="brush:python">
>>>
5, 12
>>>
</pre>

这段代码的运行结果是？ B
<pre class="brush:python">
str="{c}, {b}, {a}".format(a=5, b=9, c=7)
print(str)
</pre>

9, 7, 5
7, 9, 5
5, 9, 7


有用的函数
字符串函数
<div class="explain">
Python包含许多有用的内置函数和方法来完成常见任务。<br>

<b>join</b>一个字符串列表和另一个字符串作为分隔符。<br>

<b>replace</b>-替换另一个字符串中的一个子字符串。<br>

<b>startswith 和 endswith</b>-分别确定字符串的开始和结束是否有子字符串。<br>

若要更改字符串的大小写，可以使用lower 和 upper.。<br>

方法split 与join相反，将带有某个分隔符的字符串转换成列表。
</div>
<p class="exa"><b>例如：<b></p>

<pre class="brush:python">
print(", ".join(["spam", "eggs", "ham"]))
# 输出结果 "spam, eggs, ham"

print("Hello ME".replace("ME", "world"))
# 输出结果s "Hello world"

print("This is a sentence.".startswith("This"))
# 输出结果 "True"

print("This is a sentence.".endswith("sentence."))
# 输出结果 "True"

print("This is a sentence.".upper())
# 输出结果 "THIS IS A SENTENCE."

print("AN ALL CAPS SENTENCE".lower())
# 输出结果 "an all caps sentence"

print("spam, eggs, ham".split(", "))
# 输出结果"['spam', 'eggs', 'ham']"
</pre>

填空，把字符串大写。 upper
a = "Spam"
b = a. [space] （）


数值函数

<div class="explain">

若要查找某个数字或列表的最大值或最小值，可以使用 max or min.。<br>

要找到一个数字的距离为零（它的绝对值），使用ABS。<br>

将小数位数取整，使用round。<br>

若要查找列表的总数，请使用sum
</div>
<p class="exa"><b>例如：<b></p>
<pre class="brush:python">
print(min(1, 2, 3, 4, 0, 2, 1))
print(max([1, 4, 9, 2, 5, 6, 8]))
print(abs(-99))
print(abs(42))
print(sum([1, 2, 3, 4, 5]))
</pre>
<p class="resu"><b>结果：<b></p>

<pre class="brush:python">
>>>
0
9
99
42
15
>>>
</pre>

这段代码的运行结果是？30
<pre class="brush:python">
a=min([sum([11, 22]), max(abs(-30), 2)])
print(a)
</pre>
[space]

列表函数
<div class="explain">

Often used in conditional statements, all and any take a list as an argument, and return True if all or any (respectively) of their arguments evaluate to True (and False otherwise). 
The function enumerate can be used to iterate through the values and indices of a list simultaneously.
ALL和an都将列表作为参数，通常在条件语句中使用，如果所有参数或任何（各自）参数都计算为真（反之亦然），则返回true。

enumerate枚举函数可用于同时遍历列表的值和索引。
</div>
<p class="exa"><b>例如：<b></p>
<pre class="brush:python">
nums = [55, 44, 33, 22, 11]

if all([i > 5 for i in nums]):
   print("All larger than 5")

if any([i % 2 == 0 for i in nums]):
   print("At least one is even")

for v in enumerate(nums):
   print(v)
</pre>

<p class="resu"><b>结果：<b></p>

<pre class="brush:python">
>>>
All larger than 5
At least one is even
(0, 55)
(1, 44)
(2, 33)
(3, 22)
(4, 11)
>>>
</pre>

这段代码的运行结果是？2
<pre class="brush:python">
nums = [-1, 2, -3, 4, -5]
if all([abs(i) < 3 for i in nums]):
  print(1)
else:
  print(2)
</pre>
[space]

文本分析器

<div class="explain">这是一个示例项目，显示了一个程序，该程序分析一个示例文件，以查找每个字符占用的文本百分比。<br>

本节演示如何打开和读取文件。</div>

<pre class="brush:python">
filename = input("Enter a filename: ")

with open(filename) as f:
   text = f.read()

print(text)
</pre>
<p class="resu"><b>结果：<b></p>
<pre class="brush:python">
>>>
Enter a filename: test.txt
Ornhgvshy vf orggre guna htyl.
Rkcyvpvg vf orggre guna vzcyvpvg.
Fvzcyr vf orggre guna pbzcyvpngrq.
Syng vf orggre guna arfgrq.
Fcenfr fv orggre guna qrafr.
Ernqnovyvgl pbhagf.
Fcrpvny pnfrf nera'g fcrpvny rabthu gb oernx gur ehyrf.
Nygubhtu cenpgvpnyvgl orgnf chevgl.
Reebef fubhyq arire cnff fvyragyl.
Hayrff rkcyvpvgyl fvyraprq.
Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba bg thrff.
Gurer fubhyq or bar-- naq cersrenoylbayl bar --boivbhf jnl gb qb vg.
Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.
Abj vf orggre guna arrire.
Nygubhtu arire vf bsgra orggre guna *evtug* abj.
Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.
Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.
Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!
</pre>
<div class="tip">这只是示例内容，仅供演示之用。</div>

填空，使用with语句读取文件的内容。 with,as
[space]open(filename) [space] f:
  text = f.read()

文本分析器
  它计算字符串中字符出现的次数。
<pre class="brush:python">
def count_char(text, char):
  count = 0
  for c in text:
    if c == char:
      count += 1
  return count
</pre>

<div class="explain">该函数将文件和一个字符的文本作为参数，返回字符在文本中出现的次数。<br>

现在我们可以把它叫做我们的文件。</div>

<pre class="brush:python">
filename = input("Enter a filename: ")
with open(filename) as f:
  text = f.read()

print(count_char(text, "r"))
</pre>
<p class="resu"><b>结果：<b></p>

<pre class="brush:python">
>>>
Enter a filename: test.txt
83
>>>
</pre>
<div class="tip">字符“r”出现在文件中83次。</div>

为什么字符计数代码被放在一个函数中？A


因为它可以多次运行。
因为他运行快
因为它可以读取文件


Text Analyzer

<div class="explain">程序的下一部分查找字母表中每个字符所占的百分比。</div>
<pre class="brush:python">
for char in "abcdefghijklmnopqrstuvwxyz":
  perc = 100 * count_char(text, char) / len(text)
  print("{0} - {1}%".format(char, round(perc, 2)))
</pre>
<div class="explain">让我们把它放在一起运行这个程序：</div>

<pre class="brush:python">
def count_char(text, char):
  count = 0
  for c in text:
    if c == char:
      count += 1
  return count

filename = input("Enter a filename: ")
with open(filename) as f:
  text = f.read()

for char in "abcdefghijklmnopqrstuvwxyz":
  perc = 100 * count_char(text, char) / len(text)
  print("{0} - {1}%".format(char, round(perc, 2)))

</pre>

<p class="resu"><b>结果：<b></p>
<pre class="brush:python">
Enter a filename: test.txt
a - 4.68%
b - 4.94%
c - 2.28%
...
</pre>

代码中循环函数的目的是什么？ A

减少打印数字

节省内存

使它更精确

tuple能分割吗？ A
能
不能


哪一个列表切片反转列表中的“numbers”？ C
numbers[-1::]
numbers[::]
numbers[::-1]
 
什么可以被描述为不可变的列表？ C

A number
A dictionary
A tuple

没有返回语句的函数返回了什么？ B
False
None
0

这段代码的运行结果是？44
<pre class="brush:python">
nums = (55, 44, 33, 22)
print(max(min(nums[:2]), abs(-42)))
</pre>
[space]